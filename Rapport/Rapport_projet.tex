\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, margin=2.5cm]{geometry}
\usepackage{graphicx} 
\usepackage{natbib}
\usepackage[french]{babel}

\usepackage[default,scale=0.95]{opensans}
\usepackage[T1]{fontenc}
\usepackage{amssymb} %math
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{systeme}
\usepackage{bbm}
\usepackage{media9}
\usepackage{makecell}
\usepackage{url}
\usepackage{minted}
\usepackage{xcolor}
% \usepackage{lineno}
% \linenumbers

\usepackage{hyperref}
\hypersetup{
    % colorlinks=true,
    % linkcolor=blue,
    % filecolor=magenta,      
    % urlcolor=cyan,
    pdftitle={Projet LRC},
    %pdfpagemode=FullScreen,
    }
\urlstyle{same} %\href{url}{Text}

\renewcommand{\baselinestretch}{1.5}

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{1cm}

        \Huge
        \textbf{Rapport de projet}

        \vspace{0.5cm}
        \LARGE
        Écriture en Prolog d'un démonstrateur basé sur l'algorithme des tableaux pour la logique de description  $ \mathcal{ALC}$

        \vspace{1.5cm}

        \textbf{Charles Vin}\\
        \textbf{Barthelemy Dang-Nhu}

        \vfill



        \normalsize

        \textbf{Année :}
        2022/2023
        \hfill
        \includegraphics[width=0.25\textwidth]{./src/logo.png}
    \end{center}
\end{titlepage}

\tableofcontents
\newpage

\section{Introduction}

\section{Description générale et fonctionnement}
\subsection{Les fichiers}
Pour une meilleure compréhension du code, nous avons séparer celui-ci en plusieurs fichier. Chacun à sa spécialisation : \begin{itemize}
    \item \verb|T-A_box.pl| : C'est ici que l'utilisateur entre la TBox et la ABox initial.
    \item \verb|run.pl| : Contient le prédicat \verb|programme/0|  qui appel les grandes étapes nécessaire à la résolution.
    \item \verb|part1.pl| : Contient les fonctions liées à la première partie décrite par le sujet.
    \item \verb|part2.pl| : Contient les fonctions liées à la deuxième partie décrite par le sujet.
    \item \verb|part3.pl| : Contient les fonctions liées à la troisième partie décrite par le sujet.
    \item \verb|helper.pl| : Contient quelques prédicats utiles
\end{itemize}

\subsection{Utilisation du programme}
\subsubsection{Initialisation de la TBox et de la ABox}

\subsubsection{Lancement et saisie de la proposition à prouver}
Pour lancer le programme entrez cette commande à la racine du projet : \verb|swipl -f run.pl|. Puis dans l'interpréteur prolog utilisez le prédicat \verb|programme| pour lancer le programme.


\subsection{Exemple d'utilisation}


\section{\'Etape préliminaire de vérification et de mise en forme de la Tbox et de la Abox}
\`A ce stade les Abox et Tbox ne sont pas altérées, il est donc inutile de les mettre en argument des prédicats car on peut y accéder avec les prédicats \color{blue}cnamea, cnamena, iname, rname, equiv, inst, instR\color{black}.
\subsection{Correction syntaxique et sémentique}
Dans cette première partie nous commençons par vérifier la correction sémentique et syntaxique des deux box. Pour ce faire nous implémentons les prédicats d'arité 1 \color{blue}concept, instance, role\color{black}\ qui vérifie si des objets sont de ce type. Les cas de base sont les suivants :

\begin{minted}{prolog}
concept(C) :- cnamea(C), !.
concept(CG) :- cnamena(CG), !. 
instance(I) :- iname(I), !.
role(R) :- rname(R), !. 
\end{minted}

Le prédicat \color{blue}concept\color{black}\ nécessite de la récursivité à cause des concepts non-atomiques. Nous vérifions la grammaire avec les prédicats suivants :

\begin{minted}{prolog}
concept(not(C)) :- concept(C), !.
concept(and(C1, C2)) :- concept(C1), concept(C2), !.
concept(or(C1, C2)) :- concept(C1), concept(C2), !.
concept(some(R, C)) :- role(R), concept(C), !.
concept(all(R, C)) :- role(R), concept(C), !.
\end{minted}

Nous utilisons ces prédicats pour définir le prédicat \color{blue}definition\color{black}\ d'arité 2 qui vérifie si la définition d'une équivalence est juste : il faut que le premier élement soit un concept non-atomique et que le deuxième soit bien la définition d'un concept :
\begin{minted}{prolog}
definition(CA, CG) :- cnamena(CA), concept(CG), !.
\end{minted}

Grâce à ce prédicat nous pouvons vérifier la Tbox avec \color{blue}verif\_Tbox\color{black}\ qui prend en argument une TBox sous forme d'une liste de d'équivalence et qui vérifie la correction syntaxique et sémentique : 
\begin{minted}{prolog}
verif_Tbox([(CA, CG) | Q]) :- 
    definition(CA, CG), 
    verif_Tbox(Q).
verif_Tbox([]).
\end{minted}
On fait de même avec la Abox
\subsection{Vérification de l'autoréférencement}
Nous voulons ensuite s'assurer qu'il n'y a pas d'autoréférencement dans la définition des concepts non-atomiques. S'il y en a, au moment de dévelepper les concepts pour n'avoir que des concepts atomiques il y aura une boucle infinie. Nous implémentons le prédicat \color{blue}pautoref(C, Def)\color{black}\ qui prend en argmuent un concept non-atomique C et la définition de concept Def et qui est vraie ssi C n'est pas présent récursivement dans Def. Le cas de base est le suivant :
\begin{minted}{prolog}
pautoref(C, Def) :-cnamea(Def).
\end{minted}

Nous pouvons ainsi construire le prédicat \color{blue}verif\_Autoref(L)\color{black}\ qui prend en argument la liste des concept non-atomiques et qui vérifie s'il n'y a pas autoréferencement dans leur définition : 
\begin{minted}{prolog}
verif_Autoref([]).
verif_Autoref([C|L]) :-
	equiv(C, Def_C),
	pautoref(C, Def_C),
	verif_Autoref(L).
\end{minted}
\subsection{Mise sous forme}
Une fois que nous sommes sûr qu'il n'y a pas d'autoréférencement on peut développer les concepts non-atomiques. Nous implémentons le prédicat \color{blue}developp(C,D)\color{black}\ qui est vraie ssi D est le developpement de C. Le cas de base est le suivant : 
\begin{minted}{prolog}
developpe(C, C) :- cnamea(C).
\end{minted}
On peut ensuite écrire le prédicat \color{blue}transforme(L1,l2)\color{black}\ qui prend en argument deux box L1 et L2 et qui est vraie ssi L2 est la box équivalent à L1 mais dans laquel les concepts non-atomiques sont développés puis mis sous formes normales négatives :
\begin{minted}{prolog}
transforme([], []).
transforme([(X,C) | L], [(X,D) | M]) :- 
	developpe(C, E),
	nnf(E, D),
	transforme(L, M).
\end{minted}
\section{Saisie de la proposition à montrer}
\section{Démonstration de la proposition}

\end{document}
