\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, margin=2.5cm]{geometry}
\usepackage{graphicx} 
\usepackage{natbib}
\usepackage[french]{babel}

\usepackage[default,scale=0.95]{opensans}
\usepackage[T1]{fontenc}
\usepackage{amssymb} %math
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{systeme}
\usepackage{bbm}
\usepackage{media9}
\usepackage{makecell}
\usepackage{url}
\usepackage{minted}
\usepackage{xcolor}
% \usepackage{lineno}
% \linenumbers

\usepackage{hyperref}
\hypersetup{
    % colorlinks=true,
    % linkcolor=blue,
    % filecolor=magenta,      
    % urlcolor=cyan,
    pdftitle={Projet LRC},
    %pdfpagemode=FullScreen,
    }
\urlstyle{same} %\href{url}{Text}

\renewcommand{\baselinestretch}{1.5}

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{1cm}

        \Huge
        \textbf{Rapport de projet}

        \vspace{0.5cm}
        \LARGE
        Écriture en Prolog d'un démonstrateur basé sur l'algorithme des tableaux pour la logique de description  $ \mathcal{ALC}$

        \vspace{1.5cm}

        \textbf{Charles Vin}\\
        \textbf{Barthélémy Dang-Nhu}

        \vfill



        \normalsize

        \textbf{Année :}
        2022/2023
        \hfill
        \includegraphics[width=0.25\textwidth]{./src/logo.png}
    \end{center}
\end{titlepage}

\tableofcontents
\newpage
\section{Introduction}

\section{Description générale et fonctionnement}
\subsection{Les fichiers}
Pour une meilleure compréhension du code, nous avons séparer celui-ci en plusieurs fichier. Chacun à sa spécialisation : \begin{itemize}
    \item \verb|T-A_box.pl| : C'est ici que l'utilisateur entre la TBox et la ABox initial.
    \item \verb|run.pl| : Contient le prédicat \verb|programme/0|  qui appel les grandes étapes nécessaire à la résolution.
    \item \verb|part1.pl| : Contient les fonctions liées à la première partie décrite par le sujet.
    \item \verb|part2.pl| : Contient les fonctions liées à la deuxième partie décrite par le sujet.
    \item \verb|part3.pl| : Contient les fonctions liées à la troisième partie décrite par le sujet.
    \item \verb|helper.pl| : Contient quelques prédicats utiles
\end{itemize}

\subsection{Utilisation du programme}
\subsubsection{Initialisation de la TBox et de la ABox}

\subsubsection{Lancement et saisie de la proposition à prouver}
Pour lancer le programme entrez cette commande à la racine du projet : \verb|swipl -f run.pl|. Puis dans l'interpréteur prolog utilisez le prédicat \verb|programme| pour lancer le programme.


\subsection{Exemple d'utilisation}


\section{\'Etape préliminaire de vérification et de mise en forme de la Tbox et de la Abox}
\`A ce stade les Abox et Tbox ne sont pas altérées, il est donc inutile de les mettre en argument des prédicats car on peut y accéder avec les prédicats \color{blue}cnamea, cnamena, iname, rname, equiv, inst, instR\color{black}.
\subsection{Correction syntaxique et sémantique}
Dans cette première partie nous commençons par vérifier la correction sémantique et syntaxique des deux box. Pour ce faire nous implémentons les prédicats d'arité 1 \color{blue}concept, instance, role\color{black}\ qui vérifie si des objets sont de ce type. Les cas de base sont les suivants :

\begin{minted}{prolog}
concept(C) :- cnamea(C), !.
concept(CG) :- cnamena(CG), !. 
instance(I) :- iname(I), !.
role(R) :- rname(R), !. 
\end{minted}

Le prédicat \color{blue}concept\color{black}\ nécessite de la récursivité à cause des concepts non-atomiques. Nous vérifions la grammaire avec les prédicats suivants :

\begin{minted}{prolog}
concept(not(C)) :- concept(C), !.
concept(and(C1, C2)) :- concept(C1), concept(C2), !.
concept(or(C1, C2)) :- concept(C1), concept(C2), !.
concept(some(R, C)) :- role(R), concept(C), !.
concept(all(R, C)) :- role(R), concept(C), !.
\end{minted}

Nous utilisons ces prédicats pour définir le prédicat \color{blue}definition\color{black}\ d'arité 2 qui vérifie si la définition d'une équivalence est juste : il faut que le premier élément soit un concept non-atomique et que le deuxième soit bien la définition d'un concept :
\begin{minted}{prolog}
definition(CA, CG) :- cnamena(CA), concept(CG), !.
\end{minted}

Grâce à ce prédicat nous pouvons vérifier la Tbox avec \color{blue}verif\_Tbox\color{black}\ qui prend en argument une TBox sous forme d'une liste de d'équivalence et qui vérifie la correction syntaxique et sémantique : 
\begin{minted}{prolog}
verif_Tbox([(CA, CG) | Q]) :- 
    definition(CA, CG), 
    verif_Tbox(Q).
verif_Tbox([]).
\end{minted}
On fait de même avec la Abox
\subsection{Vérification de l'auto-référencement}
Nous voulons ensuite s'assurer qu'il n'y a pas d'auto-référencement dans la définition des concepts non-atomiques. S'il y en a, au moment de développer les concepts pour n'avoir que des concepts atomiques il y aura une boucle infinie. Nous implémentons le prédicat \color{blue}pautoref(C, Def)\color{black}\ qui prend en argument un concept non-atomique C et la définition de concept Def et qui est vraie ssi C n'est pas présent récursivement dans Def. Le cas de base est le suivant :
\begin{minted}{prolog}
pautoref(C, Def) :-cnamea(Def).
\end{minted}

Nous pouvons ainsi construire le prédicat \color{blue}verif\_Autoref(L)\color{black}\ qui prend en argument la liste des concept non-atomiques et qui vérifie s'il n'y a pas auto-référencement dans leur définition : 
\begin{minted}{prolog}
verif_Autoref([]).
verif_Autoref([C|L]) :-
	equiv(C, Def_C),
	pautoref(C, Def_C),
	verif_Autoref(L).
\end{minted}
\subsection{Mise sous forme}
Une fois que nous sommes sûr qu'il n'y a pas d'auto-référencement on peut développer les concepts non-atomiques. Nous implémentons le prédicat \color{blue}developpe(C,D)\color{black}\ qui est vraie ssi D est le développement de C. Le cas de base est le suivant : 
\begin{minted}{prolog}
developpe(C, C) :- cnamea(C).
\end{minted}
On peut ensuite écrire le prédicat \color{blue}transforme(L1,L2)\color{black}\ qui prend en argument deux box L1 et L2 et qui est vraie si et seulement si L2 est la box équivalent à L1 mais dans laquelle les concepts non-atomiques sont développés puis mis sous formes normales négatives :
\begin{minted}{prolog}
transforme([], []).
transforme([(X,C) | L], [(X,D) | M]) :- 
	developpe(C, E),
	nnf(E, D),
	transforme(L, M).
\end{minted}

\section{Saisie de la proposition à montrer}
Dans la deuxième partie, l'utilisateur peut choisir d'entrer deux types de propositions à démontrer : 
\begin{itemize}
    \item Un proposition de type $ I : C $ qui sera géré par le prédicat \color{blue}acquisition\_prop\_type1 / 3 \color{black}
    \item Un proposition de type $ C1 \sqcap C2 \sqsubseteq \bot  $ qui sera géré par le prédicat \color{blue}acquisition\_prop\_type2 / 3 \color{black}
\end{itemize}

\subsection{Proposition de type 1 : $ I : C $ }
On commence par demander à l'utilisateur d'entrer $ I $ et $ C $ par le biais du prédicat \color{blue}input\_prop\_type1\color{black}\. C'est également ici que l'on vérifie si l'entrée de l'utilisateur est correct syntaxiquement avec le prédicat \color{blue}instanciationC / 2\color{black}.
\begin{minted}{prolog}
input_prop_type1(I, CG) :-
    write('Ajoutons une instance de concept à la ABox :'), nl,
    write('Elle a la forme "I : C"'), nl,
    write('Entrez I :'),nl, 
    read(I),nl,
    write('Entrez C :'),nl, 
    read(CG),
    (instanciationC(I, CG) -> % if 
        write("Input correct")
        ; ( % else
        write('Erreur : I n\'est pas une instance déclarée ou C n\'est pas un concept'), nl,
        write('Veuillez recommencer'), nl
        % input_prop_type1(I, CG) % boucler ne semble pas fonctionner 
        )), nl.
\end{minted}
Dans la suite d'\color{blue} acquisition\_prop\_type1 \color{black}\ on effectue quelques traitements sur $ \neg C $ en remplaçant de manière récursive les identificateurs de concepts complexes par leur définition et en mettant le tout sous forme normale négative (prédicat \color{blue} transforme \color{black}). On peut ensuite ajouter le tout dans la ABox avec \color{blue} concat \color{black}.
\begin{minted}{prolog}
acquisition_prop_type1(Abi,Abi1,Tbox) :- 
    input_prop_type1(I, CG), % User input
    transforme([(I,not(CG))], [(I, CG_dev_nnf)]), % Développement + nnf
    concat(Abi,[(I, CG_dev_nnf)], Abi1), % Ajout de l'input de l'utilisateur dans la ABox
    write("Abi1"), write(Abi1). 
\end{minted}

\subsection{Proposition de type 2 : $ C1 \sqcap C2 \sqsubseteq \bot $ }
Comme précédemment, on commencer par demander à l'utilisateur d'entrer $ C1 $ et $ C2 $ par le biais du prédicat \color{blue} input\_prop\_type2 / 2 \color{black}. Et on vérifie si l'entrée de l'utilisateur est correct syntaxiquement avec le prédicat \color{blue}concept / 2\color{black}.
\begin{minted}{prolog}
input_prop_type2(C1, C2) :-
    write('Ajoutons une proposition de type 2.'), nl,
    write('Entrez C1 :'),nl, 
    read(C1),nl,
    write('Entrez C2 :'),nl, 
    read(C2),
    (concept(and(C1, C2)) -> % if 
        write("Input correct")
        ; ( % else
        write('Erreur : C1 ou C2 n\'est pas un concept déclarée'), nl,
        write('Veuillez recommencer'), nl
        % input_prop_type2(C1, C2) % boucler ne semble pas fonctionner
    )), nl.
\end{minted}
Cette fois-ci il faut générer un nom de concept aléatoire $ Random\_CName $ afin de pouvoir ajouter dans la ABox $ Random\_CName : C1 \sqcap C2 $, c'est ce qui est fait par le biais de \color{blue} genere / 1 \color{black} et \color{blue} transforme / 2 \color{black}. Puis le tout est \color{blue} concat \color{black} dans la ABox.
\begin{minted}{prolog}
acquisition_prop_type2(Abi, Abi1, Tbox) :- 
    input_prop_type2(C1, C2), % User input
    genere(Random_CName),
    transforme([(Random_CName, and(C1, C2))], [(Random_CName, and(C1_dev_nnf, C2_dev_nnf))]), % Développement + nnf
    concat(Abi, [(Random_CName, and(C1_dev_nnf, C2_dev_nnf))], Abi1), % Ajout de l'input de l'utilisateur dans la ABox
    write("Abi1"), write(Abi1).
\end{minted}

\section{Démonstration de la proposition}

\end{document}
